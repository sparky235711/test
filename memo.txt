終了
Space q q
再起動
Space q r
デバッグモードで再起動
Space q d

Ctrl-h でバックスペースにする　　.emacs.dの init.elに以下を追加
(keyboard-translate ?\C-h ?\C-?)

ウィンドウの大きさ変更 .spacemacsに以下を追加
(add-to-list 'default-frame-alist '(height . 60))
(add-to-list 'default-frame-alist '(width . 220)) 



■HELP Space h
Space h k Keyを調べる
Space ?  キーバインドを調べる
Space h d 調べる系
Space h d b キーバインドを調べるSpace？と同じかな
Space h d f 関数を調べる
Space h d m 現在のバッファで有効になっているモードと使えるキーバインドを調べる
Space h d p パッケージを調べる
Space h d s システム情報をクリップボードにコピー(messageバッファで確認できる)
Space h d v 変数を調べる

■ウィンドウ操作 Space w
Space w TAB		別のウィンドウを移動
Space w 2,3		縦に{2,3}分割
Space w f		follow-modeの切り替え
Space w b		ミニバッファに移動
Space w d		ウィンドウを消去
Space w h,j,k,l		上下左右に移動
Space w W		移動するウィンドウを選択
Space w D		消去するウィンドウを選択
Space w M		スワップするウィンドウを選択
Space 数字 Windowの移動

■バッファ操作 Space b
Space b .		バッファ移動ステート
Space b b		バッファを選択
Space b s		*scratch*バッファ
Space b d		バッファを削除
Space b h		Spacemacsのホーム画面

■ファイル操作 Space f
Space f f		ファイルを開く
Space f r		最近使ったファイルを開く
Space f j		ディレクトリを開く
Space f J		仮ファイルを開く

■Spacemacsの設定 Space f e
Space f e		Spacemacsレイヤーの操作
Space f e d		~/.spacemacsを開く
Space f e i		~/.emacs.d/init.elを開く
Space f e R		設定ファイルを再読込み

■Git操作 Space g
Space g s   Magitを起動

ディレクトリツリーを表示
Space f t
f file
t tree

h  上の階層に移動
l　下の階層に移動
s  隠しファイル表示


ディレクトリツリーで新規作成
ファイル作成
c f
ディレクトリ作成
c d

.spacemacsファイルを開く
Space f e d

設定ファイルの反映
Space f e R

Command実行
Space !

日本語
Ctrl-\

■Clojure
.cljファイルを開いた状態で
REPL
start
Space m s i
end
Space m s q

起動済みREPL
Space m s c

calc
(+ 2 4)

Ctrl-k 前回の履歴戻る
Ctrl-j 進む

変数代入
(def x 10)

関数定義
(defn func []
  (println "functest"))

(defn func [a b c]
  (+ a b c))
  
戻り値は最後の式になる。

引数の数の違いで関数を分けられる
(defn piyo
  ([] println "one")
  ([x] println "two")
  ([x y] println "three"))

可変引数
(defn fuga [& args]
  (println args))

defn は関数名をつけて後から呼び出せる仕組み
無名関数はfnで定義する

((fn [a b c] (+ a b c)) 1 2 3 )
((fn [message] (println message)) "hello world")

無名変数を変数に束縛する
(def x (fn [y] (+ y 3)))
と
(defn x [y] (+ y 3))
は同じ

fnマクロには簡略的な書き方ができる
(fn [a b c] (* a b c))
は
#(* %1 %2 %3)
と同じ（引数が一つの場合は%だけ）
(filter #(even? %) [1 2 3 4])

letを使うと狭い範囲の変数束縛ができる
(let [x 3 y 4] (println x y))

(def x 3)
(def y 4)
(println x y)
だとx,yはコード実行後も変数束縛されている

関数内で使うときなどによく使う
(defn triangle [x y] 
  (let [temp (* x y)] (/ temp 2)))

変数を区別するためにネームスペースを使用する
たいていの場合はファイルの１行目にnsを使ってこのファイルのネームスペースを宣言する
(ns abc.core)
(def cons-point [x y]
  {:x x :y y})

の場合、abc.coreのネームスペースが作成され、これ以降に続く変数、関数はabc.coreのネームスペースに所属することになる。

ネームスペースを作る際に、別のネームスペースを利用する宣言も同時に可能
(ns abc.core
  (:require [clojure.edn :as edn]))
clojure.ednという名前のネームスペースを ednという名前で利用できるようにしている
clojure.ednネームスペースにはreadという関数が用意されているので:requireで上記のように指定された場合、read関数は
edn/read で呼び出せるようになる

複数のrequire可能
(ns abc.core
  (:require [clojure.edn :as edn] [clojure.string :as cstring]))

:useを使うとネームスペース内の関数や変数を利用できるようになる
(ns abc.core
 (:use [clojure.edn]))
read で使えるようになる

nsを使わずにrequire use を使うときは ' をつける
(use 'cloure.string)
(require '[clojure.edn :as edn])
※基本的にはuseは使わなくなったらしい Clojure1.4以降では

コメント
; ここから行末までコメント
(comment "この中がコメント")
(comment (println "式もコメントになるが、正しくないとエラーになる"))
#_(list 1 2 3) ;これもコメント

四則演算
加算
(+ 1 2)   3
(+ 1.0 2.0 3.0) 6.0
減算
(-12 5)   7
(-5 3 2)  0
乗算
(* 1 2 3)  6
除算
(/ 2 3)  2/3
(/ 10.0 2.5)  4.0

インクリメント
(inc 4)   5
デクリメント
(dec 5)   4
最も小さい
(min 3 4 6)   3
最も大きい
(max 4 5 6)   6

文字列
(str "abc" "eec")   "abceec"
(str 1 2 3 )  "123"
(str)  ""

clojure.stringの関数を利用できるようにする
(require '[clojure.string :as cstring])
文字列が空かどうか
(cstring/blank? "abcd")   false
(cstring/blank? "")   true

文字列を大文字化
(cstring/upper-case "hello clojure")
小文字化
(cstring/lower-case "HELLO")

文字列長さ
(count "abcde")   5

Clojureの文字列はjavaのjava.lang.Stringなので、Stringの関数を使える

文字
単一の文字は\バックスラッシュを前につける
\A   Aという文字
\1   1という文字

キーワード
文字列と同じような役割を持つが、同じキーワードかどうかの判断が高速に行われるので、パフォーマンスが向上するメリットがある。
:abc   abcという名前のキーワード
:123   123という名前のキーワード

真偽値
true
false
nil は Javaのnull

コレクション
リスト、マップ、ベクター、セットのこと　集まり

リスト
'(1 2 3 4) 1から4の要素を持つリスト
(list 1 2 3 4)  上と同じ意味

リストの先頭を取得
(first '(1 2 3 4))  1
リストの先頭を除外して残りを取得
(rest '(1 2 3 4))    (2 3 4)
リストの最後の要素
(last '(1 2 3 4))  4
リストから必要な数を取得する
(take 3 '(1 2 3 4 5))   (1 2 3)
カウント
(count '(1 2 3))   3
要素の追加 リストは前に追加される
(conj '(1 2 3) 4)  (4 1 2 3 )

ベクター（配列）
[1 "k" 3]
(vector 1 "k" 3)
[]  空のベクター
[[1 2 3] "abc"]  入れ子

(get ["a" "b" "c"] 0)    "a" 
(["a" "b" "c"] 0)  上と同じ意味
(get ["abc" true :abc 99] 10)  nil 無効なインデックスlはnil

ベクターでもリストと同じようにfirst rest last　count conjが使える。（コレクションは全て使える）
(first ["a" "b" "c"]) "a"
(last ["a" "b" "c"]) ("b" "c")
(rest ["a" "b" "c"])  "c"
(count ["a" "b" "c"]) 3
(conj ["a" "b" "c"] "d")  ["a" "b" "c" "d"]  ベクターは最後に追加される

リストはpeek と pop でスタックとして使える
(peek '(1 2 3))  1
(pop '(1 2 3)) (2 3)
 
マップ key value を続けて記述
{"name" "Taro" "age" 10}
{:name "Taro" :age 10}
(hash-map :name "Taro" :age 10)  上と同じ

(get {:name "Taro" :age 20} :name)   "Taro"
(keys {:name "Taro" :age 20} :name)   (:name :age)
(vals {:name "Taro" :age 20} :name)   ("Taro" 20)

(def person {:name "Taro" :age 20})
(person :age)   20

セット 重複のない値のコレクション
#{:a :b :c :d}
#{1 2 3}
(set [1 2 3]) 上と同じ
(hash-set 1 2 3) 上と同じ
(set [1 2 3 3 4]) 重複削除される

(def testset (set [1 2 3]))
(get testset 3)  3
(get testset 4)  nil  値があるかないかを判断できる

遅延シーケンス
<range>
(range)  0から始まる1づつ増えていく無限の数
(range 10) 0から9までのシーケンス
(range 2 9) 2 から8までのシーケンス
(range 0 10 2) 0から始まり10未満で2づつ増えていくシーケンス(0 2 4 6 8)

<repeat>
(repeat :a)  :aが無限に続くリスト
(repead 4 :b) :bが4個のリスト

<cycle>
(cycle [:a :b :c])   (list :a :b ;c :a :b :c :a :b :c .....) という風に無限に続く

